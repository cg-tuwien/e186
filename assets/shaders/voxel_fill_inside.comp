layout(binding = 0, rgba16f) uniform restrict image3D uTex3D;
uniform vec3 uFillColor;

bool isEmpty(vec3 value)
{
    return (length(value) == 0);
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // layout declaration
void main()
{
    ivec3 size = imageSize(uTex3D);
    ivec3 pos = ivec3(gl_GlobalInvocationID.xy, 0);
    int onSurface = 0;
    int countSurfaceCrossings = 0;
    vec3 lastValue = vec3(0);
    vec3 value = vec3(0);

    // each thread walks along z at its xy
    // check if inside voxelized mesh surface via odd-even rule
    // voxelized mesh surface can have several voxel thickness, so check for empty after full voxel
    // if inside and empty, fill
    for (int i = 0; i < 128; ++i) // TODO imageSize(uTex3D).z instead of constant
    {
        pos.z = i;

        value = (imageLoad(uTex3D, pos)).rgb;

        if (isEmpty(lastValue) && !isEmpty(value)) // entered voxelized mesh surface
        {
            onSurface = 1;
        }
        if (!isEmpty(lastValue) && isEmpty(value)) // exited voxelized mesh surface
        {
            onSurface = 0;
            ++countSurfaceCrossings;
        }

        if (onSurface == 0 && mod(countSurfaceCrossings, 2) == 1) // inside voxelized mesh surface
        {
            imageStore(uTex3D, pos, vec4(uFillColor, 1));
        }

        lastValue = value;
    }
}


